## 介绍

布隆过滤器由 Burton Howard Bloom 于 1970 年提出，它是一种节省空间的概率数据结构，包括一个很长的二进制向量和一些列随机映射函数。

它可以用于检测一个元素是否存在于集合中。

<img src="https://bugstack.cn/images/article/algorithm/bloom-filter-01.png?raw=true">
<p style="text-align: center">图片来自：<a href="https://bugstack.cn/">https://bugstack.cn/</a></p>

## 优缺点

优点：

- 节省空间：一个 bit 位标识一则数据的存在信息。
- 查询高效：使用 k 个散列函数进行映射，由于 k 为常数，因此实际的时间复杂度为 $O(1)$

缺点：

- 存在误判情况：对于「不存在」的数据可能会误判为存在，对于「存在」的数据不可能发生误判
- 数据存在删除困难问题：一个 bit 位可能被多个输入数据使用，无法删除。随着时间的推移，会有越来越多的 bit
  位置为1，从而提高了误判的概率
    - 解决1：数据归档——可以定期地对一部分数据库中的老数据进行归档，然后定期使用指定时间范围内的新数据构建出一个新的
      bitmap，对老的 bitmap 进行覆盖，以此延长布隆过滤器的生命力.
    - 解决2：布谷鸟过滤器

## 误判率推演

> 内容来自：[布隆过滤器技术原理及应用实战](https://zhuanlan.zhihu.com/p/648260944)

误判率推演：

布隆过滤器的三个基本参数：

- bitmap 的长度设置为 m；
- hash_table 函数的个数设置为 k；
- bitmap 中已输入的元素个数为 n；（注意是输入的元素而非被置为 1 的 bit 位）

开始推演：

- 在输入 1 个元素，并通过 hash_table 函数进行 1 次映射时，1 个 bit 位因为这次操作被置为 1 的概率为 $1/m$；
- 反之，这个 bit 位不会因为这次操作被置为 1 的概率为 $1-1/m$；
- 进一步得到，这个 bit 位在经过 k 次 hash_table 映射后，仍然不被置为 1 的概率为 $(1-1/m)^k$；
- 进一步得到，这个 bit 位在输入 n 个元素后，仍然不被置为 1 的概率为 $(1-1/m)^(k·n)$；
- 反之，在输入 n 个元素后，1 个 bit 位被置为 1 的概率为 $1-(1-1/m)^(k·n)$；
- 每次输入一个元素时，发生误判的前提是，经过 hash_table 映射后，对应的 k 个 bit 位都在此前恰好被置为 1
  了，因此我们可以得到误判发生的概率为——$[1-(1-1/m)^(k·n)]^k$;

进一步推演：

- 在高等数学中，基于等价无穷小的规则,我们知道当 $x->0$ 时，有 $(1+x)^(1/x)~e$
- 于是我们有，当 $m->∞$ 时，$1/m -> 0$，于是有 $(1-1/m)^(-m)~e$.
- 于是有 $(1-1/m)^(k·n)=(1-1/m)^[(-m)·(-k·n/m)]~e^(-k·n/m)$
- 最终我们得到，当 $m->∞$ 时，误判概率可以简化表示为——$[1-e^(-k·n/m)]^k$.
- 在已知 m 和 n 的前提下，如何通过 k 的取值，来使得误判概率趋于最低，因此 m 和 n 对于我们而言是常量，k
  为求取的变量.
- 因此将 $e^(n/m)$ 记为常数 t，于是误判概率表达式为——$f(k)=[1-t^(-k)]^k$;
- 我们对 f(k) 进行求导，通过求取 f(k) 的极小值（f'(k)=0，f''(k)>0），最终得到当 $k·n/m=ln2$ 时，误判概率
  f(k) 取到极小值.

