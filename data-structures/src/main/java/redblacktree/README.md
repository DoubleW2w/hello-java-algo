建立在 BST 二叉搜索树的基础上，AVL、2-3树、红黑树都是自平衡二叉树（统称B-树）。

红黑树只需要保证黑色节点平衡即可。也正因红黑树在插入和删除时不需要太多的平衡操作，也让它成为；
Java中HashMap的元素碰撞后的转换、Linux的CFS进行调度算法、多路复用技术的Epoll等各类底层的数据结构实现。

1. 每个节点不是红色就是黑色。
    - 黑色决定平衡，红色不决定平衡。这对应了2-3树中一个节点内可以存放1~2个节点。

2. 根是黑色的。
    - 这条规则有时会被省略。由于根总是可以从红色变为黑色，但不一定相反，因此该规则对分析几乎没有影响。

3. 所有叶子 (NIL) 都是黑色的。
    - 红黑树的叶子节点并非传统的叶子节点，红黑树的叶子节点是null节点（空节点）且为黑色

4. 如果一个节点是红色的，那么它的两个子节点都是黑色的。
   通常这条规则也叫「不会有连续的红色节点」。
   这体现在2-3树中，一个节点最多临时会有3个节点，中间是黑色节点，左右是红色节点。2-3树中出现这样的情况后，会进行节点迁移，中间节点成为父节点，左右节点成为子节点。

5. 从给定节点到其任何后代 NIL 节点的每条路径都包含「相同数量的黑色节点」。
    - 对应2-3树中，每一层都只是有一个节点贡献了树高决定平衡性，也就是对应红黑树中的黑色节点。

红黑树则是在2-3树的基础上，只对黑色节点维护树高，所以它会使用到染色和左右旋来对树高调衡。染色与左右旋相比，减少了平衡操作


插入情况：
1.父为黑，直接插入
2.父叔为红，(父亲和叔叔)的颜色和爷爷的调换，又遵循根是黑色。
3.父亲爷爷+自己，需要调衡，进行左旋+染色（父染黑，爷爷染红，爷爷左旋）


1.父为黑，直接插入
2.父亲和叔叔为红
3.父亲为红，叔叔为黑，可左旋(父染黑，爷爷染红，爷爷为根节点进行左旋)
4.父亲为红，叔叔为黑，左旋无法解决问题（先右旋以后再左旋），右旋的目的是为了形成第三种情况